# Assignment 5 - Session 6 - Functions in R

# Q1
#Write a R program using control operators to test whether following values are prime
#numbers or not by providing a PRIME or NOT PRIME message as output :
#A. 103
#B. 82
#C. 179


v<-c(102,83,179)
primegen<-function(v){
  return(sapply(v,function(z){sum(z/1:z==z%/%1:z)})==2)
  print (v)
}
primegen (103)
primegen (82)
primegen (179)

# OR

# To generate Prime numbers, we are using If and Else conditional statements with
# explicit statemeents Prime number and Not a Prime Number .
prime_num <- function(pn){
  
  if(sum(pn/1:pn==pn%/%1:pn)==2)
    print("Prime Number")
  else
    print("Not a prime number")
  
}

prime_num(103)
prime_num(82)
prime_num(179)

to_find_prime<-is.prime <- function(num) {
  if (num == 2) {
    print("Prime")
  } else if  (any(num %% 2:(num-1) == 0)) {
    Print("Not Prime")
  }else {
    TRUE
  }
}
to_find_prime

to_find_prime(103)
to_find_prime(82)
to_find_prime(179)

################################################################

# Q2 Write a R program using control operators to identify letter u and 
#a both occur in the #following words:
# 1. above
# 2. unit
# 3. Under

# For this purpose, a combination of which() and strsplit() are used,
# which returns the position of the character in the given string.

string_1="above"
string_2="unit"
string_3="Under"
which(strsplit(string_1, "")[[1]]=="u")
which(strsplit(string_2, "")[[1]]=="u")
which(strsplit(string_3, "")[[1]]=="u")


#pos = gregexpr('pattern', x) is the syntax

# gregexpr() returns positions of every match in a string
unlist(gregexpr(pattern ='u',"above"))
unlist(gregexpr(pattern ='u',"unit"))
unlist(gregexpr(pattern ='u',"Under"))

# gregexpr() returns positions of every match in a string
x<-c("above","unit", "Under")
pos<-gregexpr('u', x)
pos


#To get the position of a regular expression match in a vector x 
#of text strings---
#grep() returns the index of the matching string in the given vector,
# and not the position of the matching character in the string itself:
pos_A = grep('u', x)
pos_A

lapply(strsplit(x, ''), function(x) which(x == 'u'))

a<-str_locate(x, "u")
a

#Looking for position of character in a given string---

# For this a combination of which() and strsplit() are used

s1<-"above"
s2<-"unit"
s3<-"Under"

which(strsplit(s1, '')[[1]]=='u')
which(strsplit(s2, '')[[1]]=='u')
which(strsplit(s3, '')[[1]]=='u')

################################################################

#3. Write a function that to calculate BMI (Body Mass Index):
#  BMI for a person is defined as their body mass divided by the square of their height
#The weight is in kilograms and the height in meters or
#(The weight can be in pounds and the height in inches)* 703
#Check your BMI ??? :
#  Category BMI range -                   kg/m2
#Very severely underweight              less than 15
#Severely underweight                   from 15.0 to 16.0
#Underweight                            from 16.0 to 18.5
#Normal (healthy weight)                from 18.5 to 25
#Overweight                             from 25 to 30
#Obese Class I (Moderately obese)       from 30 to 35
#Obese Class II (Severely obese)        from 35 to 40
#Obese Class III (Very severely obese)   over 40

#It is a common knowledge, that weight is increasing with height. 
#To compensate for the influence of height on weight, Body Mass Index
#(BMI) was introduced that can be calculated as:

#  BMI =  weight
#        ----------
#         height*height
#where weight is measured in kilograms and height is measured in meters

BMI<- function(height,weight){
  return(0.45455*Weight_in_Kilograms%%(.0254*Height_in_Meters)^2)
}

# My height is 5 feet 9 inches and weight is 73 kgs.
#Kg as per Metric BMI formula
Weight_in_Kilograms<-73
Weight_in_Kilograms

# Conversion of height from Inches to metres
Height_in_Meters<-c(5.9* 703)
Height_in_Meters

# Applying these outcomes to BMI formula:
# As per the formulae measures given in Assignment Question
BMI(4147.7,73)
# As per the formulae measures generated by Automatic Calculator
# by using http://www.rapidtables.com/convert/length/inch-to-meter.htm 
BMI(0.14986,73)    

# My BMI is 33.18

############################################################################

#4. Write a function called sum_of_cubes, that calculates the 
#sum of cubes of the first n natural numbers :
#  if we have two numbers : 1, 2 then sum of squares is 9 ( 1^3 + 2^3)
#if we have three numbers : 1, 2, 3 then sum of squares is 36 
#( 1^3 + 2^3 + 3^3)

sum_of_cubes<-function(n)
{
  n^2*(n+1)^2/4
}

sum_of_cubes (1:10)

###############################################################
#5. Write a function to calculate the mode (highest frequency) 
#of the following vector:
# x = c(2,3,3,4,4,5,6,7,9,10)

mode <- function(x) {
  fx <- unique(x)
  fx[which.max(tabulate(match(x, fx)))]
}

x = c(2,3,3,4,4,5,6,7,9,10)
mode(x)
# OR
mode(c(2,3,3,4,4,5,6,7,9,10))


# Alternative Code----
mode_A <- function(x) {
  if (is.numeric(x)) {
    x_vector <- table(x)
    return(as.numeric(names(x_vector)[which.max(x_vector)]))
  }
}

x = c(2,3,3,4,4,5,6,7,9,10)

mode_A(c(2,3,3,4,4,5,6,7,9,10))

######################################################################

#6. Write a function to calculate the no. of prime numbers 
#of the following vector :
#  x = c(2,2,3,3,4,5,7,11,15,19,24,29)

primer=function(v){ 
  return(regexpr("^1$|^(11+?)\\1+$",unlist(lapply(v,function(z){paste(rep("1",z),sep='',collapse='')})),
                 perl=TRUE)== -1) 
} 

# OR
#primes<-function(v){ 
#  return(v[sapply(v,function(z){sum(z/1:z==z%/%1:z)==2})]) 
# } 
#primes(x)

x <- c(2,2,3,3,4,5,7,11,15,19,24,29) 
(x)[primer(x)]

count <- function(x, n)
{ 
  length((which(x == n)))
}
#########################################################################

# 7. Create a R package for calculating the count of prime numbers , name it as
# "CountPrime"

#a) Start by opening a new .R file. Make sure your default directory is clear by 
#typing rm(list= ls()). Check to see that it is empty using ls() .
#(you should see character(0))

rm(list = ls())
ls()

# b) Write the code for your functions in this .R file. You can create one file with all of your
#functions or create separate files for each function. Save these files somewhere 
#where you can easily retrieve them.

# c) Install the 'devtools' package
install.packages("devtools")

# d) Open a new project in RStudio. Go to the 'File' menu and click on 'New Project'.
#Then select 'New Directory,' and 'R Package' to create a new R package.
# The name given to this newly crated package in R is called as "CountPrime".

# e) After typing the name of the package, upload the .R file that was 
# created in step 1 under 'Create package based on source files'. Click 
#'Create project.'

# f) On the lower right hand side (i.e. 4th quadrant) of the screen, 
# the name of newly created file directory should be visible. This 'R' folder
#contains the code for your functions. Depending on your version of RStudio, 
#the help files may have been generated automatically as .Rd or "R documentation" 
#files. 

#g) File > New File > R Documentation, enter the title of the function and select
#'Function' under the 'Rd template' menu. 
#NOTE: You will need to complete this step if you add more functions to your package at a
#later point, even if RStudio automatically generated R documentation files when you initially
#created the package

#h) Now you are ready to compile your package named "CountPrime". Go to 'Build' on the top toolbar and select 'Build
# and Reload' (note you can also use the keyboard shortcut Ctrl+Shift+B). If this works, your
# package will automatically load and you will see library(mynewpackage) at the bottom of
# your console. Test your functions to make sure they work

# i) Go back and edit the documentation (the help file) for each function. Open 
# each .Rd file, add a brief description of the package "CountPrime", define its 
# arguments and, if applicable, values, and include at least one example. Then,
# re-compile your package and test out your documentation in the R console (?myfun).
# NOTE: You will need to re-compile (repeating this particular step or step 8)
#each time the changes needs to be made to your functions or documentation.

# j) Once you have finished creating your functions and documentation, 
# compiled your package "CountPrime",and double checked that the functions 
# and help files work, copy the entire folder containing your package 
# to the Dropbox folder with your name on it.

#####################################################################
#8. Perform below operations using Data.frame and Data.table
#a. Load 2 files (.csv) and show it on screen ( F1 - empno, deptid,mgr_id , F2 - empno,
#                                               sal, DOJ)

# Ans 8 a
# Creating two data frames namely - F1 and F2.
F1 <- data.frame(
  empno<-c(101, 102, 103, 104, 105, 106, 107, 108, 109, 110,NA,115),
  deptid<-c("Admin", "Admin","Technical","BD","Functional","Functional", "Support", "Support", "HR", "Technical","Logistics","House-Keeping"),  
  mgr_id<-c("MGR_1","MGR_2", "MGR_6", "MGR_3", "MGR_4", "MGR_5", "MGR_8", "MGR_9", "MGR_10","MGR_7","MGR_11",NA),
  stringsAsFactors = FALSE
) 

F1

F2 <- data.frame(
  empno<-c(101, 102, 103, 104, 105, 106, 107, 108, 109, 110,NA,115),
  sal<-c(10000,13000,11500,14000, 15000, 8500, 9000, 7000, 10000,11500,9500,7500),
  DOJ<-c("2015-01-20","2013-09-16","2011-03-19","2016-03-29","2013-07-02","2016-12-19","2011-08-23", "2014-09-15", "2014-03-03","2015-03-23","2009-10-31","2009-01-10"),
  stringsAsFactors = FALSE
  )
F2
  


install.packages("data.table")
install.packages("sqldf")
install.packages("dplyr")
install.packages("plyr")

library(data.table)
library(sqldf)
library(dplyr)
library(plyr)

F1<-read.table ("E://Back up 1/ACADGILD/F1.csv",header = TRUE,sep=",")
F1

F2<-read.table ("E://Back up 1/ACADGILD/F2.csv",header = TRUE,sep=",")
F2

#b. Perform Equi Join

#EQUI JOIN performs a JOIN against equality or matching column(s) values of 
#the associated tables. An equal sign (=) is used as comparison operator in 
#the where clause to refer equality.

#You may also perform EQUI JOIN by using JOIN keyword followed by ON keyword
#and then specifying names of the columns along with their associated tables 
#to check equality.

#Syntax:
  
#  SELECT column_list 
#FROM table1, table2....
#WHERE table1.column_name =
#  table2.column_name; 

#or

#SELECT *
 # FROM table1 
#JOIN table2
#[ON (join_condition)]

merge(F1,F2,ON[(F1.empno=F2.empno)]=TRUE)


#c) Left Outer Join
# Syntax: merge(df1,df2, all.x=TRUE)


   merge(F1, F2, all.F1 = TRUE)
  
  
#d) Right Outer Join
# Syntax: merge(df1,df2, all.y=TRUE)

  
  merge(F1,F2, all.F2=TRUE)
 
#e) Perform full outer join
#Syntax: merge(x, y, all.x = TRUE, all.y = TRUE)
 
# A full outer join keeps all observations in x and y.   
merge(F1,F2,all.F1=TRUE,all.F2=TRUE)

#f. Perform filter operation -Eg find all the rows for which col1 is null
#is.na will showcase all the values present in a table or dataframe
is.na(F1$empno)
is.na(F2$empno)

# OR
#subset will display only the given row containing the desired values for eg.
# in this case - Null values 
subset(F1, is.na(F1$empno))
subset(F2, is.na(F2$empno))

# g.Perform group by, sum, average operation

sqldf("SELECT F2.sal,F1.deptId, Sum(F2.sal),Avg(F2.sal) FROM F2
INNER JOIN F1 
ON F2.empno = F1.empno 
WHERE F2.sal > 0
GROUP BY F1.deptId")


# h) Perform (A "-" B) operation
char_concatenate<-paste("A", "B", sep = "-")
char_concatenate

#i) #Create a derived column (empname in F2) - do some data transformation 
#on that

F2$empname<-(F2$empno)
F2$empname

# OR
a<-F2 %>% mutate(empname=c("Tom", "Jerry", "Dennis the Menace", "Sad Sack","Laurel","Hardy","Richie Rich","Poopoye","NA","Mickey Mouse", "Donald Duck","TinTin"))
a

# To do  data transformation,-----


#j. Create a "working" test that example
#Write output for each in separate files (eg- equijoin.csv ,leftoutjoin.csv)




#9. Create R functions for the following operations:
#a. Find out unique combinations of data based on a particular column 
#or group of columns.
#i. Example:

F1<-data.frame(empno, deptid,mgr_id)
F1

# unique returns a vector, data frame or array like x but with 
#duplicate elements/rows removed

unique(deptid, incomparables = FALSE)

#rapply() and sapply() will give the output as the count of unique or 
#distinct values

rapply(F1,function(deptid)length(unique(deptid)))

sapply(F1, function(deptid) length(unique(deptid)))

sqldf("SELECT F2.sal,F1.deptId, Sum(F2.sal),Avg(F2.sal) FROM F2
INNER JOIN F1 ON F2.empno = F1.empno 
WHERE F2.sal > 0
      GROUP BY F1.deptId")

# OR - By using sqldf() or SELECT statement
sqldf("SELECT F2.sal,F1.deptId FROM F2
         Inner Join F1
      ON F2.empno = F1.empno
      Where F2.Sal>10000
      GROUP BY F1.deptId")
#################################################################

#Ques9 b) Select count(distinct stdid) from student group by classid
# Creating a data frame by the name of student group

studentgroup<- data.frame(
  studentid<-c("Stu_1","Stu_2","Stu_3","Stu_5", "Stu_7","Stu_9","Stu_1","Stu_5",
               "Stu_7","Stu_9"),
  classid<-c(5,9,7,7,9,NA,3,NA,1,2),
  sectionid<-c(1,3,NA,2,2,2,2,NA,3,2),
  stringsAsFactors = FALSE
) 
studentgroup
class(studentgroup)

class_info<-sqldf("Select classid,count(distinct(studentid)) as Student_ID 
      From studentgroup
      Where studentid>0
      Group By classid")
class_info
class(studentgroup)

# OR

class_info_Alt<-sqldf("Select sg.classid,count(distinct sg.studentid)) as Student_ID 
                    From studentgroup
                    Group By sg.classid") 
class_info_Alt

b<-sqldf("SELECT sg.classid,COUNT (distinct sg.studentid)
         FROM studentgroup
         Group BY sg.classid")
b
##########################################

#c) Select count(distinct stdid) from student group by classid, sectionid

section_id_info<-sqldf("Select classid,sectonid,count(distinct(classid)) as Standard_ID
                       From studentgroup
                       Group_by classid,sectionid")
section_id_info

####################################################################

#d) Write a function to find out duplicate entries based on a key or 
#group of keys

duplicates <- function(x, as.bool = FALSE) {
  is.dup <- !(!duplicated(x) & rev(!duplicated(rev(x))))
  if (as.bool) { is.dup } else { x[is.dup] }
}

duplicates <- function(studentgroup, as.bool = FALSE) {
  is.dup <- !(!duplicated(studentgroup) & rev(!duplicated(rev(studentgroup))))
  if (as.bool) { is.dup } else { studentgroup[is.dup] }
}
duplicates(studentid)

###################################################################

#10. Create R functions for the following operations:
# a. Find out if there are any nulls in a dataset or in some 
#specific number of columns

#The syntax for identification of Null values in a given particular
#column is as follows:-
(is.na(x[1]))

#By applying this formula to a data frame or a table for a Particular or 
# specified column then----

(is.na(studentgroup[2]))

# The resultant output is TRUE wherever Null values(NA or NaN) are present 
# in the given table or a data-frame.

# Alternatively we can write a function in R for finding out the Null or
# Missing values


# A missing value is one whose value is unknown. Missing values are represented 
# in R by the NA symbol. NA is a special value whose properties are different from 
# other values. NA is one of the very few reserved words in R: you cannot give 
# anything this name. Missing values are often legitimate: values really are 
# missing in real life. NAs can arise when you read in a Excel spreadsheet with
# empty cells.

#Syntax - Function for Null Values
missing_val_func<-for (Var in names(df)) {
  missing <- sum(is.na(df[,Var]))
  if (missing > 0) {
    print(c(Var,missing))
  }
}


#By Applying this function to a given dataframe then---

missing_val_func<-for (Var in names(studentgroup)) {
  missing <- sum(is.na(studentgroup[,Var]))
  if (missing > 0) {
    print(c(Var,missing))
  }
}

# OR

# By using sapply() as follows----

sapply(studentgroup, function(x) sum(is.na(x)))

# b. Write a function to read data from hdfs and dump it back to hdfs

#a) To enable this you first need to get the R package:

install.packages("rhadoop")
# b) You can also wget the package

#wget https://cran.r-project.org/src/contrib/Archive/rHadoopClient/rHadoopClient_0.2.tar.gz
#and then
# c)

install.packages("/path/to/package")
# and d)now you can read a file in using the rHadoopClient:

rHadoopClient::read.hdfs("/path/to/data.csv")
#That's all you need to get started.

#This allows you to change your file read steps in your R scripts to point 
#to HDFS and still run your R scripts as you are used to doing.

data=from.dfs("file_path/test_short.csv",make.input.format(format="csv",sep=","))
mydata=data$val

##########################################################################

#11. Create R functions for the following operations:

#a. Remove duplicates from a given vector and return it back.
x <- c(1, 1, 4, 5, 4, 6)
x

#  To find the position of duplicate elements in x, use duplicated() as follows:
duplicated(x)

# To Extract duplicate elements and display/showcase these values, the following 
#function is used:
x[duplicated(x)]

#b. Compute count of distinct

x <- c(1, 1, 4, 5, 4, 6)
x

# To extract the Count of unique/distinct elements in the given vector:

# a) Unique()can be used to specify the values    
unique(x) 

# OR
#b) combination of length() and unique()are used to give the actual count
# of the values

length(unique(x))

#c. Concatenate two strings.
# Syntax: paste (..., sep = " ", collapse = NULL)

# For concatenation of two strings, paste() is used as follows:

paste("India","Rio de Janeiro","Addis Ababa","Sri Lanka","Tierra Del Feugo",
      "Hong Kong", "U.S.A.","Dar es Salaam","Ulan Bator","Phnom Penh",
      sep='~~~',collapse=NULL)

#d. Perform Column-wise/Row-wise sum using apply function.
# To perform Column-wise count, apply() is applied as follows:

bird_count_per_day <- matrix(c(3,2,4,6,5,1,8,6,1), ncol=3)
colnames(bird_count_per_day) <- c('sparrow','dove','crow')
bird_count_per_day

apply(bird_count_per_day, 2, sum, na.rm=TRUE)
#Here the value of the second parameter in apply(), 2, indicates the column and 
#that the sum should be performed for each Column of the matrix.

# To perform Row-wise count, apply() is applied as follows:
v<-matrix(c(1,4,2,5,3,6,6,15), ncol=4)
colnames(v)<-c('v1','v2','v3','v4')
v

apply(v,1,sum)
#Here the value of the second parameter in apply(), 1, indicates the Row 
# and that the sum or addition operation should be performed for 
#each Row of the matrix.

#e. Get list of files in an hdfs path.


#f. Delete a file from hdfs if it exists.

########################################################################

#12 Create R functions for the following operations:

#a. Load some csv data from hdfs.


#b. Get latest hive partition given a base hdfs path (<basePath>/date=20150201).



#c. Rename column names in a dataframe - 
studentgroup<- data.frame(
  studentid<-c("Stu_1","Stu_2","Stu_3","Stu_5", "Stu_7","Stu_9","Stu_1","Stu_5", "Stu_7","Stu_9"),
  classid<-c(5,9,7,7,9,NA,3,NA,1,2),
  sectionid<-c(1,3,NA,2,2,2,2,NA,3,2),
  stringsAsFactors = FALSE
) 
studentgroup


colnames(studentgroup)<- c("Test_1","Test_2","Test_3")    
studentgroup

# OR

#Rename "new" column name
colnames(studentgroup)[1]<-"Test_1"
colnames(studentgroup)[2]<-"Test_2"
colnames(studentgroup)[3]<-"Test_3"

studentgroup

#  d. Drop given column from a data frame

# Syntax for subset() is as follows:

# To drop a particular column from a data frame. subset() is used as follows:
studentgroup_redefined <- subset(studentgroup, select = c("Test_1","Test_3"))
studentgroup_redefined

# By using subset(), it will retain the columns that are specified in the above 
# argument. Rest of the colums that remain unspecified are dropped from the 
# given dataframe.

# OR
df = studentgroup[,!(names(studentgroup) %in% c("Test_2"))]
df

#e. Illustrate the difference between NA, NULL, NaN.

# Difference between NA,NULL and NaN

# Many a times the dataset will include NULL, NA, or NaN values. These work 
# somewhat differently from "normal" values, and may require explicit testing.

# Some examples of comparisons with NA,NULL and NaN values are as under:

x <- NULL
x > 5
# logical(0)

y <- NA
y > 5
# NA


z <- NaN
z > 5
# NA
#Here's how to test whether a variable has one of these values:

is.null(x)
# TRUE

is.na(y)
# TRUE

is.nan(z)
# TRUE
#Note that NULL is different from the other two. NULL means that there 
#is no value, while NA and NaN mean that there is some value, although 
#one that is perhaps not usable. Here's an illustration of the difference:

# Is y null?
is.null(y)
# FALSE

# Is x NA?
is.na(x)
# logical(0)

#If functions like mean() or sum()  are executed on a vector containing NA or NaN values, 
#they will return NA and NaN, which is generally unhelpful.

#Removing bad values from a vector
#These values can be removed from a vector by filtering using is.na() or is.nan().

vy<-c(1,  2,  3, NA,  5)
vy
# Resultant Output is: 1  2  3 NA  5
vy[ !is.na(vy) ]
#Resultant output is:
# 1  2  3  5

vz<-c(1,   2,   3, NaN,   5)
# Resultant output is: 1   2   3 NaN   5
vz[ !is.nan(vz) ]
#
#Resultant output is: 1  2  3  5

#There is a lot of subtlety in the treatment of these values.  
#A good way to understand the distinction between  NA, NaN and NULL is through 
#some examples as given below:

#####-----NA------##### 	                                     

NA                                       
#[1] NA                                     

class(NA)
#Output - [1]   "logical"

NA > 1
#Output - [1] NA


#####-----NULL------#####   
Null
#Output - NULL 
#Error: object 'Null' not found

class(NULL)
#Output -[1]   "NULL"

NULL > 1
# Output -logical(0)


#####-----NaN------#####  
NaN
#Output - [1] NaN

class(NaN)
#Output - "numeric"

NaN > 1
#Output - [1] NA


###############################
#f. Return true if and only if all rows of given vector satisfy a certain condition.

#sum() returns true directly, if and only if all rows of given vector satisfy certain condition(s).
#This is done bycounting the number of TRUE values in a logical vector.
# Syntax for this is given below:

sum(x, na.rm=TRUE)

#sum will return NA by default if any of the values are NA.  
#na.rm=TRUE ignores NA values in the sum (logical or numeric).

####################################################################
#g. Compute number of unique combinations in a data frame grouped by certain columns.
Biological_unique_combo<-data.frame(Species=c(rep("M",4),"N",rep("O",3),"P","P"), 
                                    Effect=c(rep("Birth",3), rep("Growth & Development",4),
                                             "Adulthood", rep("Mortality",2)), 
                                    Concentration=c(1.2,1.4,1.3,1.5,1.6,1.2,1.1,1,1.3,1.4))
Biological_unique_combo

# OR
library(sqldf)
sqldf("select Species, Effect,
      avg(Concentration) as `Concentration`
      from Biological_unique_combo
      group by Species, Effect")

#################################################
